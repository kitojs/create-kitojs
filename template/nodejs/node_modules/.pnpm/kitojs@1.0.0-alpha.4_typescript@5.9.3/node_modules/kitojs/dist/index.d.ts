import { ServerOptionsCore } from "@kitojs/kito-core";

//#region ../types/src/http/request.d.ts
type CommonHeaderNames = "accept" | "accept-encoding" | "accept-language" | "authorization" | "cache-control" | "content-type" | "content-length" | "cookie" | "host" | "origin" | "referer" | "user-agent" | "x-forwarded-for" | "x-forwarded-host" | "x-forwarded-proto" | "x-requested-with";
interface RequestHeaders extends Record<string, string | string[] | undefined> {
  accept?: string;
  "accept-encoding"?: string;
  "accept-language"?: string;
  authorization?: string;
  "cache-control"?: string;
  "content-type"?: string;
  "content-length"?: string;
  cookie?: string;
  host?: string;
  origin?: string;
  referer?: string;
  "user-agent"?: string;
  "x-forwarded-for"?: string;
  "x-forwarded-host"?: string;
  "x-forwarded-proto"?: string;
  "x-requested-with"?: string;
}
interface KitoRequest {
  get method(): string;
  get url(): string;
  get headers(): RequestHeaders;
  get body(): unknown;
  get params(): Record<string, string>;
  get query(): Record<string, string | string[]>;
  get cookies(): Record<string, string>;
  get pathname(): string;
  get search(): string | null;
  get protocol(): string;
  get hostname(): string;
  get ip(): string;
  get ips(): string[];
  get secure(): boolean;
  get xhr(): boolean;
  get originalUrl(): string;
  header(name: CommonHeaderNames): string | undefined;
  header(name: string): string | undefined;
  queryParam(name: string): string | string[] | undefined;
  param(name: string): string | undefined;
  cookie(name: string): string | undefined;
  json<T = unknown>(): T;
  text(): string;
  get raw(): {
    body: Buffer;
    headers: RequestHeaders;
    url: string;
    method: string;
  };
}
//#endregion
//#region ../types/src/schema/base.d.ts
interface SchemaDefinition$1 {
  params?: SchemaType;
  query?: SchemaType;
  body?: SchemaType;
  headers?: SchemaType;
  response?: ResponseSchemaDefinition;
}
interface ResponseSchemaDefinition {
  [statusCode: number]: SchemaType;
}
type InferSchemaRequest<T extends SchemaDefinition$1> = {
  params: T["params"] extends SchemaType ? InferType<T["params"]> : Record<string, string>;
  query: T["query"] extends SchemaType ? InferType<T["query"]> : Record<string, string | string[]>;
  body: T["body"] extends SchemaType ? InferType<T["body"]> : unknown;
  headers: T["headers"] extends SchemaType ? InferType<T["headers"]> : RequestHeaders;
};
interface SchemaType {
  _type: unknown;
  _optional: boolean;
  _default?: unknown;
  // biome-ignore lint/suspicious/noExplicitAny: ...
  _serialize?(): any;
}
type InferType<T extends SchemaType> = T extends {
  _default: infer D;
} ? D : T extends {
  _optional: true;
} ? T["_type"] | undefined : T["_type"];
//#endregion
//#region ../types/src/http/response.d.ts
type CommonResponseHeaderNames = "content-type" | "content-length" | "cache-control" | "etag" | "expires" | "last-modified" | "location" | "set-cookie" | "access-control-allow-origin" | "access-control-allow-methods" | "access-control-allow-headers" | "access-control-allow-credentials" | "vary" | "x-powered-by" | "x-frame-options" | "x-content-type-options" | "strict-transport-security";
interface KitoResponse<TResponseSchema = unknown> {
  status(code: number): KitoResponse<TResponseSchema>;
  sendStatus(code: number): void;
  header(name: CommonResponseHeaderNames, value: string): KitoResponse<TResponseSchema>;
  header(name: string, value: string): KitoResponse<TResponseSchema>;
  headers(headers: Record<CommonResponseHeaderNames, string>): KitoResponse<TResponseSchema>;
  headers(headers: Record<string, string>): KitoResponse<TResponseSchema>;
  append(field: CommonResponseHeaderNames, value: string): KitoResponse<TResponseSchema>;
  append(field: string, value: string): KitoResponse<TResponseSchema>;
  set(field: CommonResponseHeaderNames, value: string): KitoResponse<TResponseSchema>;
  set(field: string, value: string): KitoResponse<TResponseSchema>;
  get(field: CommonResponseHeaderNames): string | undefined;
  get(field: string): string | undefined;
  type(contentType: string): KitoResponse<TResponseSchema>;
  contentType(contentType: string): KitoResponse<TResponseSchema>;
  cookie(name: string, value: string, options?: CookieOptions): KitoResponse<TResponseSchema>;
  clearCookie(name: string, options?: CookieOptions): KitoResponse<TResponseSchema>;
  send(data: TResponseSchema extends SchemaType ? InferType<TResponseSchema> : unknown): void;
  json(data: TResponseSchema extends SchemaType ? InferType<TResponseSchema> : unknown): void;
  text(data: string): void;
  html(data: string): void;
  redirect(url: string, code?: number): void;
  location(url: string): KitoResponse<TResponseSchema>;
  attachment(filename?: string): KitoResponse<TResponseSchema>;
  download(path: string, filename?: string): void;
  sendFile(path: string, options?: SendFileOptions): void;
  vary(field: string): KitoResponse<TResponseSchema>;
  links(links: Record<string, string>): KitoResponse<TResponseSchema>;
  format(obj: Record<string, () => void>): KitoResponse<TResponseSchema>;
}
interface CookieOptions {
  domain?: string;
  expires?: Date;
  httpOnly?: boolean;
  maxAge?: number;
  path?: string;
  secure?: boolean;
  signed?: boolean;
  sameSite?: boolean | "lax" | "strict" | "none";
}
interface SendFileOptions {
  maxAge?: number;
  root?: string;
  lastModified?: boolean;
  headers?: Record<string, string>;
  dotfiles?: "allow" | "deny" | "ignore";
  acceptRanges?: boolean;
  cacheControl?: boolean;
  immutable?: boolean;
}
//#endregion
//#region ../types/src/context.d.ts
// biome-ignore lint/complexity/noBannedTypes: ...
interface KitoContext<TSchema extends SchemaDefinition$1 = {}> {
  req: KitoRequest & InferSchemaRequest<TSchema>;
  res: KitoResponse;
}
// biome-ignore lint/complexity/noBannedTypes: ...
type Context<TSchema extends SchemaDefinition$1 = {}> = KitoContext<TSchema>;
//#endregion
//#region ../types/src/handlers.d.ts
type NextFunction = () => void | Promise<void>;
type MiddlewareHandler<TSchema = unknown, TExtensions = unknown> = (ctx: KitoContext<TSchema> & TExtensions, next: NextFunction) => void | Promise<void>;
type RouteHandler<TSchema extends SchemaDefinition, TExtensions> = (ctx: KitoContext<TSchema> & TExtensions) => void | Promise<void> | unknown | Promise<unknown>;
//#endregion
//#region ../types/src/server.d.ts
interface ServerOptions {
  port?: number;
  host?: string;
  trustProxy?: boolean;
  maxRequestSize?: number;
  timeout?: number;
}
// biome-ignore lint/complexity/noBannedTypes: ...
interface KitoServerInstance<TExtensions = {}> {
  use(middleware: MiddlewareDefinition | MiddlewareHandler): KitoServerInstance<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  get<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  get<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  post<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  post<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  put<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  put<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  delete<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  delete<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  patch<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  patch<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  head<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  head<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  options<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  options<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServerInstance<TExtensions>;
  route(path: string): RouteChain<TExtensions>;
  listen(callback?: () => void): Promise<ServerOptions>;
  listen(port?: number, callback?: () => void): Promise<ServerOptions>;
  listen(port?: number, host?: string, callback?: () => void): Promise<ServerOptions>;
  close(): void;
}
//#endregion
//#region ../types/src/routes.d.ts
interface MiddlewareDefinition {
  type: "function" | "schema";
  handler?: MiddlewareHandler;
  schema?: SchemaDefinition$1;
  global: boolean;
}
// biome-ignore lint/complexity/noBannedTypes: ...
type RouteChain<TExtensions = {}> = {
  // biome-ignore lint/complexity/noBannedTypes: ...
  get<TSchema extends SchemaDefinition$1 = {}>(handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  get<TSchema extends SchemaDefinition$1 = {}>(middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  get<TSchema extends SchemaDefinition$1 = {}>(middlewaresOrHandler: (MiddlewareDefinition | TSchema)[] | RouteHandler<TSchema, TExtensions>, handler?: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  post<TSchema extends SchemaDefinition$1 = {}>(handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  post<TSchema extends SchemaDefinition$1 = {}>(middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  post<TSchema extends SchemaDefinition$1 = {}>(middlewaresOrHandler: (MiddlewareDefinition | TSchema)[] | RouteHandler<TSchema, TExtensions>, handler?: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  put<TSchema extends SchemaDefinition$1 = {}>(handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  put<TSchema extends SchemaDefinition$1 = {}>(middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  put<TSchema extends SchemaDefinition$1 = {}>(middlewaresOrHandler: (MiddlewareDefinition | TSchema)[] | RouteHandler<TSchema, TExtensions>, handler?: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  delete<TSchema extends SchemaDefinition$1 = {}>(handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  delete<TSchema extends SchemaDefinition$1 = {}>(middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  delete<TSchema extends SchemaDefinition$1 = {}>(middlewaresOrHandler: (MiddlewareDefinition | TSchema)[] | RouteHandler<TSchema, TExtensions>, handler?: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  patch<TSchema extends SchemaDefinition$1 = {}>(handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  patch<TSchema extends SchemaDefinition$1 = {}>(middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  patch<TSchema extends SchemaDefinition$1 = {}>(middlewaresOrHandler: (MiddlewareDefinition | TSchema)[] | RouteHandler<TSchema, TExtensions>, handler?: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  head<TSchema extends SchemaDefinition$1 = {}>(handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  head<TSchema extends SchemaDefinition$1 = {}>(middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  head<TSchema extends SchemaDefinition$1 = {}>(middlewaresOrHandler: (MiddlewareDefinition | TSchema)[] | RouteHandler<TSchema, TExtensions>, handler?: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;

  // biome-ignore lint/complexity/noBannedTypes: ...
  options<TSchema extends SchemaDefinition$1 = {}>(handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  options<TSchema extends SchemaDefinition$1 = {}>(middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  // biome-ignore lint/complexity/noBannedTypes: ...
  options<TSchema extends SchemaDefinition$1 = {}>(middlewaresOrHandler: (MiddlewareDefinition | TSchema)[] | RouteHandler<TSchema, TExtensions>, handler?: RouteHandler<TSchema, TExtensions>): RouteChain<TExtensions>;
  end(): KitoServerInstance<TExtensions>;
};
//#endregion
//#region ../types/src/schema/string.d.ts
interface StringSchema extends SchemaType {
  _type: string;
  min(length: number): StringSchema;
  max(length: number): StringSchema;
  length(length: number): StringSchema;
  email(): StringSchema;
  url(): StringSchema;
  uuid(): StringSchema;
  regex(pattern: RegExp): StringSchema;
  optional(): OptionalStringSchema;
  default(value: string): DefaultStringSchema;
}
interface OptionalStringSchema extends Omit<StringSchema, "optional" | "default"> {
  _optional: true;
  default(value: string): DefaultStringSchema;
}
interface DefaultStringSchema extends Omit<StringSchema, "optional" | "default"> {
  _optional: true;
  _default: string;
}
//#endregion
//#region ../types/src/schema/number.d.ts
interface NumberSchema extends SchemaType {
  _type: number;
  min(value: number): NumberSchema;
  max(value: number): NumberSchema;
  int(): NumberSchema;
  positive(): NumberSchema;
  negative(): NumberSchema;
  optional(): OptionalNumberSchema;
  default(value: number): DefaultNumberSchema;
}
interface OptionalNumberSchema extends Omit<NumberSchema, "optional" | "default"> {
  _optional: true;
  default(value: number): DefaultNumberSchema;
}
interface DefaultNumberSchema extends Omit<NumberSchema, "optional" | "default"> {
  _optional: true;
  _default: number;
}
//#endregion
//#region ../types/src/schema/boolean.d.ts
interface BooleanSchema extends SchemaType {
  _type: boolean;
  optional(): OptionalBooleanSchema;
  default(value: boolean): DefaultBooleanSchema;
}
interface OptionalBooleanSchema extends Omit<BooleanSchema, "optional" | "default"> {
  _optional: true;
  default(value: boolean): DefaultBooleanSchema;
}
interface DefaultBooleanSchema extends Omit<BooleanSchema, "optional" | "default"> {
  _optional: true;
  _default: boolean;
}
//#endregion
//#region ../types/src/schema/array.d.ts
interface ArraySchema<T extends SchemaType> extends SchemaType {
  _type: InferType<T>[];
  min(length: number): ArraySchema<T>;
  max(length: number): ArraySchema<T>;
  length(length: number): ArraySchema<T>;
  optional(): OptionalArraySchema<T>;
  default(value: InferType<T>[]): DefaultArraySchema<T>;
}
interface OptionalArraySchema<T extends SchemaType> extends Omit<ArraySchema<T>, "optional" | "default"> {
  _optional: true;
  default(value: InferType<T>[]): DefaultArraySchema<T>;
}
interface DefaultArraySchema<T extends SchemaType> extends Omit<ArraySchema<T>, "optional" | "default"> {
  _optional: true;
  _default: InferType<T>[];
}
//#endregion
//#region ../types/src/schema/object.d.ts
interface ObjectSchema<T extends Record<string, SchemaType>> extends SchemaType {
  _type: { [K in keyof T]: InferType<T[K]> };
  shape: T;
  optional(): OptionalObjectSchema<T>;
  default(value: { [K in keyof T]: InferType<T[K]> }): DefaultObjectSchema<T>;
}
interface OptionalObjectSchema<T extends Record<string, SchemaType>> extends Omit<ObjectSchema<T>, "optional" | "default"> {
  _optional: true;
  default(value: { [K in keyof T]: InferType<T[K]> }): DefaultObjectSchema<T>;
}
interface DefaultObjectSchema<T extends Record<string, SchemaType>> extends Omit<ObjectSchema<T>, "optional" | "default"> {
  _optional: true;
  _default: { [K in keyof T]: InferType<T[K]> };
}
//#endregion
//#region ../types/src/schema/literal.d.ts
interface LiteralSchema<T extends string | number | boolean> extends SchemaType {
  _type: T;
  optional(): OptionalLiteralSchema<T>;
  default(value: T): DefaultLiteralSchema<T>;
}
interface OptionalLiteralSchema<T extends string | number | boolean> extends Omit<LiteralSchema<T>, "optional" | "default"> {
  _optional: true;
  default(value: T): DefaultLiteralSchema<T>;
}
interface DefaultLiteralSchema<T extends string | number | boolean> extends Omit<LiteralSchema<T>, "optional" | "default"> {
  _optional: true;
  _default: T;
}
//#endregion
//#region ../types/src/schema/union.d.ts
interface UnionSchema<T extends SchemaType[]> extends SchemaType {
  _type: InferType<T[number]>;
  optional(): OptionalUnionSchema<T>;
  default(value: InferType<T[number]>): DefaultUnionSchema<T>;
}
interface OptionalUnionSchema<T extends SchemaType[]> extends Omit<UnionSchema<T>, "optional" | "default"> {
  _optional: true;
  default(value: InferType<T[number]>): DefaultUnionSchema<T>;
}
interface DefaultUnionSchema<T extends SchemaType[]> extends Omit<UnionSchema<T>, "optional" | "default"> {
  _optional: true;
  _default: InferType<T[number]>;
}
//#endregion
//#region src/schemas/builders.d.ts
/**
 * Schema builder utilities for creating type-safe request validation schemas.
 *
 * @example
 * ```typescript
 * import { t, schema } from 'kitojs';
 *
 * const userSchema = schema({
 *   params: t.object({
 *     id: t.str().uuid()
 *   }),
 *   body: t.object({
 *     name: t.str().min(1).max(50),
 *     email: t.str().email(),
 *     age: t.num().min(0).optional()
 *   })
 * });
 *
 * app.post('/users/:id', [userSchema], ctx => {
 *   // ctx.req.params.id is validated as UUID
 *   // ctx.req.body is type-safe and validated
 * });
 * ```
 */
declare const t: {
  /**
   * Creates a string schema builder.
   *
   * @returns String schema with validation methods
   *
   * @example
   * ```typescript
   * t.str() // basic string
   * t.str().min(3).max(50) // length constraints
   * t.str().email() // email validation
   * t.str().uuid() // UUID validation
   * t.str().optional() // optional field
   * t.str().default('hello') // default value
   * ```
   */
  str(): StringSchema;
  /**
   * Creates a number schema builder.
   *
   * @returns Number schema with validation methods
   *
   * @example
   * ```typescript
   * t.num() // basic number
   * t.num().min(0).max(100) // range constraints
   * t.num().int() // integer only
   * t.num().positive() // positive numbers
   * t.num().optional() // optional field
   * t.num().default(0) // default value
   * ```
   */
  num(): NumberSchema;
  /**
   * Creates a boolean schema builder.
   *
   * @returns Boolean schema with validation methods
   *
   * @example
   * ```typescript
   * t.bool() // basic boolean
   * t.bool().optional() // optional field
   * t.bool().default(false) // default value
   * ```
   */
  bool(): BooleanSchema;
  /**
   * Creates an array schema builder.
   *
   * @template T - Type of array items
   * @param item - Schema for array items
   * @returns Array schema with validation methods
   *
   * @example
   * ```typescript
   * t.array(t.str()) // string array
   * t.array(t.num().positive()) // array of positive numbers
   * t.array(t.object({ name: t.str() })) // array of objects
   * t.array(t.str()).min(1).max(10) // length constraints
   * ```
   */
  array<T extends SchemaType>(item: T): ArraySchema<T>;
  /**
   * Creates an object schema builder.
   *
   * @template T - Object shape definition
   * @param shape - Object property schemas
   * @returns Object schema with validation methods
   *
   * @example
   * ```typescript
   * t.object({
   *   name: t.str(),
   *   age: t.num(),
   *   email: t.str().email().optional()
   * })
   *
   * // Nested objects
   * t.object({
   *   user: t.object({
   *     profile: t.object({
   *       bio: t.str()
   *     })
   *   })
   * })
   * ```
   */
  object<T extends Record<string, SchemaType>>(shape: T): ObjectSchema<T>;
  /**
   * Creates a literal schema for exact value matching.
   *
   * @template T - Literal value type
   * @param value - Exact value to match
   * @returns Literal schema
   *
   * @example
   * ```typescript
   * t.literal('admin') // matches only "admin"
   * t.literal(42) // matches only 42
   * t.literal(true) // matches only true
   * ```
   */
  literal<T extends string | number | boolean>(value: T): LiteralSchema<T>;
  /**
   * Creates a union schema for multiple possible types.
   *
   * @template T - Array of possible schema types
   * @param schemas - Schemas to union
   * @returns Union schema
   *
   * @example
   * ```typescript
   * // String or number
   * t.union(t.str(), t.num())
   *
   * // Enum-like literals
   * t.union(
   *   t.literal('admin'),
   *   t.literal('user'),
   *   t.literal('guest')
   * )
   *
   * // Complex types
   * t.union(
   *   t.object({ type: t.literal('user'), name: t.str() }),
   *   t.object({ type: t.literal('guest') })
   * )
   * ```
   */
  union<T extends SchemaType[]>(...schemas: T): UnionSchema<T>;
};
//#endregion
//#region src/helpers/schema.d.ts
/**
 * Creates a typed schema definition for request validation.
 * This is a type helper that preserves schema structure for type inference.
 *
 * @template T - Schema definition type
 * @param definition - Schema definition object
 * @returns The same schema definition with preserved types
 *
 * @example
 * ```typescript
 * import { schema, t } from 'kitojs';
 *
 * const userSchema = schema({
 *   params: t.object({
 *     id: t.str().uuid()
 *   }),
 *   query: t.object({
 *     limit: t.num().min(1).max(100).default(10)
 *   }),
 *   body: t.object({
 *     name: t.str().min(1),
 *     email: t.str().email()
 *   }),
 *   headers: t.object({
 *     authorization: t.str()
 *   })
 * });
 *
 * app.post('/users/:id', [userSchema], ctx => {
 *   // All request parts are type-safe and validated
 *   const id = ctx.req.params.id; // string (UUID validated)
 *   const limit = ctx.req.query.limit; // number
 *   const name = ctx.req.body.name; // string
 * });
 * ```
 */
declare function schema<T extends SchemaDefinition$1>(definition: T): T;
//#endregion
//#region src/helpers/middleware.d.ts
/**
 * Creates a typed middleware definition.
 *
 * @template TExtensions - Type of context extensions available in the middleware
 * @param handler - Middleware function that processes requests
 * @returns Middleware definition object
 *
 * @example
 * ```typescript
 * import { middleware } from 'kitojs';
 *
 * // Basic middleware
 * const logger = middleware((ctx, next) => {
 *   console.log(`${ctx.req.method} ${ctx.req.url}`);
 *   next();
 * });
 *
 * // Authentication middleware
 * const auth = middleware((ctx, next) => {
 *   const token = ctx.req.headers.authorization;
 *
 *   if (!token || !verifyToken(token)) {
 *     ctx.res.status(401).send('Unauthorized');
 *     return;
 *   }
 *
 *   next();
 * });
 *
 * // Async middleware
 * const asyncAuth = middleware(async (ctx, next) => {
 *   const user = await validateUser(ctx.req.headers.authorization);
 *   if (!user) {
 *     ctx.res.status(401).send('Unauthorized');
 *     return;
 *   }
 *   await next();
 * });
 *
 * // Using middleware
 * app.use(logger); // global
 *
 * // Route middleware
 * app.get('/protected', [auth], ctx => {
 *   ctx.res.send('Secret data');
 * });
 * ```
 */
declare function middleware<TExtensions = any>(handler: MiddlewareHandler<any, TExtensions>): MiddlewareDefinition;
//#endregion
//#region src/server/server.d.ts
/**
 * Main server class for Kito framework.
 * Provides HTTP routing, middleware support, and context extensions.
 *
 * @template TExtensions - Type of custom extensions added to the context
 *
 * @example
 * ```typescript
 * const app = new KitoServer();
 *
 * app.get('/', ctx => {
 *   ctx.res.send('Hello World!');
 * });
 *
 * app.listen(3000);
 * ```
 */
declare class KitoServer<TExtensions = {}> implements KitoServerInstance<TExtensions> {
  private globalMiddlewares;
  private serverOptions;
  private coreServer;
  private extensionFn?;
  /**
   * Creates a new Kito server instance.
   *
   * @param options - Server configuration options
   * @param options.port - Port to listen on (default: 3000)
   * @param options.host - Host to bind to (default: "0.0.0.0")
   * @param options.trustProxy - Trust X-Forwarded-* headers
   * @param options.maxRequestSize - Maximum request body size in bytes
   * @param options.timeout - Request timeout in milliseconds
   */
  constructor(options?: ServerOptions);
  /**
   * Extends the request context with custom properties or methods.
   *
   * @template TNewExtensions - Type of the new extensions
   * @param fn - Function that adds extensions to the context
   * @returns A new server instance with extended context type
   *
   * @example
   * ```typescript
   * interface Database {
   *   query: (sql: string) => Promise<any>;
   * }
   *
   * const app = server().extend<{ db: Database }>(ctx => {
   *   ctx.db = createDatabase();
   * });
   *
   * app.get('/users', ctx => {
   *   const users = await ctx.db.query('SELECT * FROM users');
   *   ctx.res.json(users);
   * });
   * ```
   */
  extend<TNewExtensions = unknown>(fn: (ctx: KitoContext & TExtensions & Partial<TNewExtensions>) => TNewExtensions | void): KitoServer<TExtensions & TNewExtensions>;
  /**
   * Registers a global middleware that runs for all routes.
   *
   * @param middleware - Middleware function or definition
   * @returns The server instance for chaining
   *
   * @example
   * ```typescript
   * app.use((ctx, next) => {
   *   console.log(`${ctx.req.method} ${ctx.req.url}`);
   *   next();
   * });
   * ```
   */
  use(middleware: MiddlewareDefinition | MiddlewareHandler): KitoServer<TExtensions>;
  /**
   * Registers a GET route.
   *
   * @template TSchema - Request schema type
   * @param path - Route path (supports :params)
   * @param handler - Route handler function
   * @returns The server instance for chaining
   *
   * @example
   * ```typescript
   * app.get('/users/:id', ctx => {
   *   ctx.res.json({ id: ctx.req.params.id });
   * });
   * ```
   */
  get<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  /**
   * Registers a GET route with middlewares and/or schema validation.
   *
   * @template TSchema - Request schema type
   * @param path - Route path
   * @param middlewares - Array of middlewares and/or schema definition
   * @param handler - Route handler function
   * @returns The server instance for chaining
   */
  get<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  /**
   * Registers a POST route.
   *
   * @template TSchema - Request schema type
   * @param path - Route path
   * @param handler - Route handler function
   * @returns The server instance for chaining
   */
  post<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  post<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  /**
   * Registers a PUT route.
   *
   * @template TSchema - Request schema type
   * @param path - Route path
   * @param handler - Route handler function
   * @returns The server instance for chaining
   */
  put<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  put<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  /**
   * Registers a DELETE route.
   *
   * @template TSchema - Request schema type
   * @param path - Route path
   * @param handler - Route handler function
   * @returns The server instance for chaining
   */
  delete<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  delete<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  /**
   * Registers a PATCH route.
   *
   * @template TSchema - Request schema type
   * @param path - Route path
   * @param handler - Route handler function
   * @returns The server instance for chaining
   */
  patch<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  patch<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  /**
   * Registers a HEAD route.
   *
   * @template TSchema - Request schema type
   * @param path - Route path
   * @param handler - Route handler function
   * @returns The server instance for chaining
   */
  head<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  head<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  /**
   * Registers an OPTIONS route.
   *
   * @template TSchema - Request schema type
   * @param path - Route path
   * @param handler - Route handler function
   * @returns The server instance for chaining
   */
  options<TSchema extends SchemaDefinition$1 = {}>(path: string, handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  options<TSchema extends SchemaDefinition$1 = {}>(path: string, middlewares: (MiddlewareDefinition | TSchema)[], handler: RouteHandler<TSchema, TExtensions>): KitoServer<TExtensions>;
  /**
   * Creates a route builder for chaining multiple HTTP methods on the same path.
   *
   * @param path - Base path for all routes in the chain
   * @returns Route chain builder
   *
   * @example
   * ```typescript
   * app.route('/api/users')
   *   .get(ctx => ctx.res.json(users))
   *   .post(ctx => ctx.res.json({ created: true }))
   *   .end();
   * ```
   */
  route(path: string): RouteChain<TExtensions>;
  private addRoute;
  private serializeSchema;
  private fuseMiddlewares;
  private isSchemaDefinition;
  /**
   * Starts the HTTP server and begins listening for requests.
   *
   * @param portOrCallback - Port number or ready callback
   * @param hostOrCallback - Host string or ready callback
   * @param maybeCallback - Ready callback
   * @returns Promise resolving to server configuration
   *
   * @example
   * ```typescript
   * // Empty
   * await app.listen();
   *
   * // Simple
   * await app.listen(3000);
   *
   * // With callback
   * await app.listen(3000, () => {
   *   console.log('Server ready!');
   * });
   *
   * // With port and host
   * await app.listen(3000, '127.0.0.1', () => {
   *   console.log('Server ready on 127.0.0.1:3000');
   * });
   * ```
   */
  listen(portOrCallback?: number | (() => void), hostOrCallback?: string | (() => void), maybeCallback?: () => void): Promise<ServerOptionsCore>;
  /**
   * Closes the server and stops accepting new connections.
   */
  close(): void;
}
/**
 * Creates a new Kito server instance.
 *
 * @param options - Server configuration options
 * @returns New server instance
 *
 * @example
 * ```typescript
 * import { server } from 'kitojs';
 *
 * const app = server();
 *
 * app.get('/', ctx => {
 *   ctx.res.send('Hello World!');
 * });
 *
 * app.listen(3000);
 * ```
 */
declare function server(options?: ServerOptions): KitoServer<{}>;
//#endregion
export { Context, KitoContext, KitoServer, middleware, schema, server, t };
//# sourceMappingURL=index.d.ts.map